1. 引用型变量
    1. 普通变量  int a;
    2. 指针变量  int *p;
    3. 引用变量  int &c = a;
        1. 数据类型  &引用变量名 = 原有变量;
        2. 给一个原有变量再起一个别名
        3. 必须是普通变量,不能是指针变量
        4. 定义时必须说明是给那个变量起的别名,必须赋值
        5. 初始化后，它就一直引用该变量，不能再引用别的变量了
2. 方法参数的传递方式
    1. 按值传递(克隆人)
    2. 按地址传递:效果:在方法体重通过形参改变参数数值,方法调用结束,实参的值也会改变(内存地址)
    3. 按引用传递:效果:与按地址传递一样
3. 内存区域
   1. 堆
   2. 栈
   3. 值栈
      1. 形参变量的内存
      2. 方法的局部变量
4. const修饰变量
    1. 修饰普通变量,表示是常量,值不能变; const int a = 10;
    2. 修饰指针变量
        1. 常量指针:指向的值不可以改，指向可以改(可以不赋初值) const int* p1;
        2. 指针常量:指向的值可以改变,指向不能改变(必须赋初值)int* const p2 = &num1;
        3. 同时修饰:都不能变 const int* const p3 = &num1;
    3. 修饰引用类型:不同通过引用变量去修改原始变量的数值
5. const函数相关
    1. 返回值类型 函数名称(参数列表) int add(int a, int b)
    2. const修饰函数参数:与const修饰变量的含义相同
    3. const修饰返回值类型:不能修改返回值,并且也必须用const变量接返回值
    4. const修饰整个函数:成员函数不能改变成员属性的数值,const成员函数只能调用const函数
6. 方法参数默认值
    1. 函数参数的默认值从右边开始赋值
    2. 从右到左,除非停止赋值,不能有空余
7. 方法重载
    1. 类中的多个方法具有相同的方法名,不同的参数列表
    2. 参数列表不同
        1. "参数的个数"不同
        2. "参数的类型"不同
    3. 与返回值类型没有关系,与参数名没有关系
    4. 方法重载是多态的一种表现形式
新知识:
8. "面向对象的高级语言试图用人的世界观改造计算机的世界观"(计算机模拟现实生活)
9. 消息:
10. 判断一门语言是不是面向对象的编程语言的标准:"是否满足三个特征"
11. 封装:
    1. 把属性与方法(行为)"封装"到一个类中(类中封装变量与方法)
    2. 隐藏属性与行为(部分属性行为公开,部分半公开,部分私有)
    3. 隐藏方法实现细节
12. 实体类 Entity Class
    1. 属性都是private私有的
    2. 每个属性有两个公有的方法get与set, 称为"访问器"
    3. 属性首字母都为小写，那生成的访问器就是加上get set后属性首字母变为大写。
    4. 返回值类型 get属性名(){//get有返回值没有参数
           return 属性
       }
    5. void set 属性(数据类型 参数名) {//set有参数没有返回值
            this->属性名 = 参数名;//参数名与属性名相同
       }









      







